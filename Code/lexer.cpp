
  /********************************************************************************************************************/
  // Name: Ankur Chaudhary   ASU ID: 1206281930
  // Desc: Program to design a Lexical Analyzer. It takes two functions isOperator(), isDelimiter() which
  //       identifies operators and delimiters.It also has a function lexer() which takes string argument
  //       and checks the state based on a transition table to give a final state. Final State is calculated based
  //       on current state from table, starting with curr=0 and input=0, based on next charcater input, the next
  //       state is calculated. Based on state output is displayed.

  // Contents: Ankur_Chaudhary_Project1.cpp
  //           Ankur_Chaudhary_Project1_input.txt
  //           Ankur_Chaudhary_Project1_output.txt
  //           Ankur_Chaudhary_Project1_input_new.txt
  //           Ankur_Chaudhary_Project1_output_new.txt
  //	       Makefile
  //	       Ankur_Output -Executable file generated by makefile

  // Assumption: Program compiled and executed on Ubuntu 13.04. gcc compiler creates a character
  //             carrige return at end by itself. That has been taken care of here.
  /*******************************************************************************************************************/

#include "lexer.h"

//Linked List for Tokens
   //extern void splitLine(string);
   //extern class Token;
 
 vector<Token> myTokens;

  Token::Token(string a, string b, int c){
	  tokenName=a;
	  tokenWord=b;
	  tokenLine=c;
  }

   /*
   string Token::showName(){
   	return tokenName;
   }
   
   string Token::showWord(){
   	return tokenWord;
   }
   
   int Token::showLine(){
   	return tokenLine;
   }
  */
   
 int line_num=0;
 

int arr[100][100];

//const char state = 'S0';
int input,flag=0,flag_err,state;

//ofstream out;


bool isKeyWord(string str1){

	if(str1== "int"||str1== "float"||str1== "char"||str1== "string"||str1== "read"
		    ||str1== "print"||str1== "if"||str1== "else"||str1== "while"||str1== "return"||
		    str1== "void"||str1== "boolean"||str1== "for"||str1== "true"||
		    str1== "false"||str1=="integer"||str1=="boolean"){
		    	return true;
		    }
	else{ 
	 return false;	
	}
	
}

bool isType(string str1){
   if(str1== "int"||str1== "float"||str1== "char"||str1== "string"
     ||str1=="true"||str1=="false"||str1=="boolean"||str1=="integer"){
		    	return true;
		    }
	else{ 
	 return false;	
	}
	
}

//Check Operators

 
bool isOperator(char ch){
	switch(ch){
		case '+':
		case '-':
		case '/':
		case '*':
		case '%':
		case '<':
		case '>':
		case '!':
		case '|':
		case '=': return true;
		break;
		default: return false;
	}
}

//Check Demlimiters

bool isDelimiter(char ch1){
	switch(ch1){
		case '(':
		case ')':
		case '{':
		case '}':
		case '[':
		case ']':
		case ';':
		case ',':	
		case ':': return true;
		break;
		default: return false;
	}
 }

//Check Hexadecimal
   bool isHex(char c){

   	switch(c){

	case '0': case '1': case '2': case '3': case '4': case '5': case '6':
   	case '7': case '8': case '9': case 'a': case 'b': case 'c': case 'd':
	case 'e': case 'f': case 'A': case 'B': case 'C': case 'D': case 'E':
	case 'F':
	return true;
	break;
	default: return false;
    }
   }

//Check Octal
   bool isOct(char c){
   	switch(c){
	case '0': case '1': case '2': case '3': case '4': case '5': case '6':
   	case '7': return true;
   	break;
   	default: return false;
    }
   }


//Transition Table Function
  int calcState(int curr, char letter){

   /*Transition Table for the tokens*/

    arr[1][1]=1;
	arr[1][2]=1;
	arr[3][1]=3;
	arr[3][2]=3;
	arr[3][3]=3;
	arr[4][1]=4;
	arr[4][2]=4;
	arr[5][1]=5;
	arr[6][1]=6;
	arr[6][2]=6;
	arr[7][1]=7;
	arr[7][2]=7;
	arr[8][1]=8;
	arr[9][1]=9;
	arr[10][1]=10;
	arr[10][2]=10;
	arr[11][1]=11;
	arr[13][1]=13;
	arr[14][1]=14;
	arr[14][2]=14;
	arr[14][3]=14;
	arr[15][1]=15;
	arr[16][1]=16;
	arr[19][1]=19;
    arr[19][2]=19;
	arr[20][1]=20;
	arr[20][2]=20;
	arr[21][1]=21;
	arr[22][1]=22;
	arr[22][2]=22;
	arr[23][1]=23;


	   if(flag_err==0){

	 /*Check ID*/
   if(curr==0&&(isalpha(letter)||letter=='_'||letter=='$')){
   	curr=1;
   	input=1;
    return arr[curr][input];
   }

	if(curr==1&&(isalpha(letter)||isdigit(letter)||letter=='_'||letter=='$')){
		curr=1;
		input=2;
	 return arr[curr][input];
	}


     /*Check Integer , Octal , Hexadecimal , Float */

     if(curr==0&&letter=='0'){
     	curr=3;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==0&&isdigit(letter)){
      curr=7;
	  input=1;
	  return arr[curr][input];
     }

      if(curr==7&&!isdigit(letter)&&letter!='.'){
     	curr=13;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==7&&isdigit(letter)){
     	curr=7;
     	input=2;
     	return arr[curr][input];
     }



     if(curr==3 && isOct(letter)&&letter!='x'){
     	curr=4;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==4&&!isOct(letter)){
     	flag_err=-100;
		curr=20;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==20&&!isOct(letter)){
     	curr=20;
     	input=2;
     	return arr[curr][input];
     }

     if(curr==4&&isOct(letter)){
     	curr=4;
     	input=2;
     	return arr[curr][input];
     }

	 if(curr==3&&letter=='x'){
	 	curr=5;
	 	input=1;
	 	return arr[curr][input];
	 }

     if(curr==5&&isHex(letter)){
     	curr=6;
     	input=1;
     	return arr[curr][input];
     }

      if(curr==6&&!isHex(letter)){
     	 flag_err=-100;
		 curr=19;
     	input=1;
     	return arr[curr][input];
     }



     if(curr==19&&!isHex(letter)){
     	curr=19;
     	input=2;
     	return arr[curr][input];

     }


      if(curr==6&&isHex(letter)){
     	curr=6;
     	input=2;
     	return arr[curr][input];
     }

      if(curr==3&&letter=='.'){
      	curr=8;
      	input=1;
      	return arr[curr][input];
      }

     if(curr==7&&letter=='.'){
     	curr =8;
     	input=1;
     	return arr[curr][input];
     }


     if(curr==8&&isdigit(letter)){
     	curr=10;
     	input=1;
      	return arr[curr][input];
     }

     if(curr==0&&letter=='.'){
     	curr=8;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==11&&isdigit(letter)){
     	curr=10;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==10&&isdigit(letter)){
     	curr=10;
     	input=2;
     	return arr[curr][input];
     }

     /*Character Along with Escape Sequences*/

     if(curr==0&&letter=='\''){
     	curr=14;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==14&&input==1&&letter=='\\'){
     	curr=14;
     	input=2;
     	flag++;
     	return arr[curr][input];
     }

     if(curr==14&&(input==1||input==2)&&letter!= '\\'){
     	curr=14;
     	input=3;
     	flag++;
     	return arr[curr][input];
      }

      if(curr==14&&(flag==1||flag==2)&&letter=='\''){
     	curr=15;
     	input=1;
     	return arr[curr][input];
     }

     /*Check Strings */
        if(curr==0&&letter=='\"'){
     	curr=21;
     	input=1;
     	return arr[curr][input];
     }

     if(curr==21&&letter!='\"'){
     	curr=22;
     	input=1;
     	return arr[curr][input];
     }

      if(curr==22&&letter!='\"'){
         	curr==22;
         	input=2;
         	return arr[curr][input];
      }

      if(curr==22&&letter=='\"'){
     	curr=23;
     	input=1;
     	return arr[curr][input];
       }

       flag_err=-100;


	  }

  }


/*Lexer Function*/
  void lexer(string str1){

   int flag_key=0,flag_s=0;
   /*
   string Keyword [80] = {
   	               "read","print",
                   "if", "else",
				   "while", "return",
				   "int", "float",
				   "void", "char",
				   "string", "boolean","for",
				   "true","false"
                 };
   */
      //int state = 0;
      //len = str1.length();

      	if(isKeyWord(str1)){
      		flag_key=1;
      		state=18;
      	}
      
      if(str1=="\"\\\"\""){
      	flag_s=1;
      	state=23;
      }
	  for(int j=0;j<str1.length()&&flag_key!=1&&flag_s==0;j++){
      	state = calcState(state,str1[j]);
      }

	  switch(state){
	  	case 1://out<<"IDENTIFIER"<<"\t"<<str1<<"\n";
	  		myTokens.push_back(Token("IDENTIFIER",str1,line_num));
	  	break;
	    case 3://out<<"INTEGER"<<"\t"<<str1<<"\n";
	    	myTokens.push_back(Token("int",str1,line_num));
		break;
		case 4://out<<"OCTAL"<<"\t"<<str1<<"\n";
			myTokens.push_back(Token("OCTAL",str1,line_num));
		break;
		case 6://out<<"HEXADECIMAL"<<"\t"<<str1<<"\n";
			myTokens.push_back(Token("HEXADECIMAL",str1,line_num));
		break;
		case 7://out<<"INTEGER"<<"\t"<<str1<<"\n";
			myTokens.push_back(Token("int",str1,line_num));
		break;
		case 10://out<<"FLOAT"<<"\t"<<str1<<"\n";
			myTokens.push_back(Token("float",str1,line_num));
		break;
		case 15://out<<"CHARACTER"<<"\t"<<str1<<"\n";
			myTokens.push_back(Token("char",str1,line_num));
			flag=0;
		break;
		case 18://out<<"KEYWORD"<<"\t"<<str1<<"\n";
		    if(str1=="boolean"||str1=="bool"){
		       myTokens.push_back(Token("boolean",str1,line_num));	
		    }
		    else{
		      myTokens.push_back(Token("KEYWORD",str1,line_num));	
		    }			
		break;
		case 23://out<<"STRING"<<"\t"<<str1<<"\n";
			myTokens.push_back(Token("string",str1,line_num));
			flag_s=0;
		break;

		default: //out<<"UNDEFINED"<<"\t"<<str1<<"\n";
		myTokens.push_back(Token("UNDEFINED",str1,line_num));
		     flag_err=0; flag=0;
	  }

	  state=0;
  }

 /*Split Line to pass Line by Line*/
  void splitLine(string pattern){

        line_num++;
  	 	string str,str1,s,oper_delim;

		int flag_str=0,count=0,count1=0,flag_char=0,flag_end;


		   int i=0,j=0;

			do{

                if(pattern[i]=='\r'){
                                    i++;

                                    }
				count=1;count1=1;



					if(pattern[i]=='\''&&pattern[i+1]=='\\'&&
					   pattern[i+2]=='\''&&pattern[i+3]=='\''){
					   	str+=pattern[i];
						str+=pattern[i+1];
						str+=pattern[i+2];
						str+=pattern[i+3];
					   	lexer(str);
					   	i=i+4;
						str="";

					   }

					if(pattern[i]=='\"'&&pattern[i+1]=='\\'&&
					   pattern[i+2]=='\"'&&pattern[i+3]=='\"'){
					   	str+=pattern[i];
						str+=pattern[i+1];
						str+=pattern[i+2];
						str+=pattern[i+3];
					   	lexer(str);
					   	i=i+4;
						str="";

					   }

				  if(pattern[i]=='\''){

					  for(int k=i+1;k<pattern.length();k++){
                  		  count1++;


						if(pattern[k]=='\''){
                  			flag_char=1;
                  			break;
                  		}
                  	}

                  }

                  if(pattern[i]=='\''&&flag_char!=1){

					str+=pattern[i];
                  	lexer(str);
                  	i++;
					str="";
                  }


                   if(flag_char==1){
                 	str="";
					 do{
                 		str+=pattern[i];
                 		i++;
                 		count1--;
                 	}while(count1!=0);
                 	lexer(str);
                 	 flag_char=0;
					 str="";
                 }


		/*Check for Strings
		  This will allow string containing spaces to pass through
		 */

				  if(pattern[i]=='\"'){

					  for(int j=i+1;j<pattern.length();j++){
                  		  count++;
						  if(pattern[j]=='\"'){
                  			flag_str=1;
                  			break;
                  		}
                  		else if(j+1==pattern.length()){
                  			  flag_str=1;
                  	 	     }

                  	}

                  }

                 if(flag_str==1){
                 	str="";
					 do{
                 		str+=pattern[i];
                 		i++;
                 		count--;
                 	}while(count!=0);
                 	lexer(str);
                 	 flag_str=0;
					 str="";
                 }


				else{

                if(pattern[i]!=' '&&!isDelimiter(pattern[i])&&!isOperator(pattern[i])
				   &&flag_str==0&&flag_char==0){

					    str+=pattern[i];
		   			    i++;

                                           if(pattern[i]=='\r'){
                                             lexer(str);
                                             str="";
                                             i++;
                                               continue;
                                            }

					   if(pattern[i]=='\"'){
					   	lexer(str);
					   	str="";
					   	continue;
					   }

					if(pattern[i]=='\''){
						i--;
					}


		   			 if(i==pattern.length()){
		   			   lexer(str);
		   			  }

		   	       }

		   	 else {
		   	        if(str!=""){
					   lexer(str);
				      }
                
                
					if(isOperator(pattern[i])){
		   				//out<<"DELIMITER"<<"\t"<<pattern[i]<<"\n";
                        s=pattern[i];
                        if(pattern[i]=='+'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='='){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
						if(pattern[i]=='-'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='*'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='/'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='%'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
						if(pattern[i]=='<'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='>'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='!'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                         if(pattern[i]=='&'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
                        if(pattern[i]=='|'){
                        	myTokens.push_back(Token("Operator",s,line_num));
                        }
					
						i++;
		   			}
		   			
		   			if(isDelimiter(pattern[i])){
		   				 s=pattern[i];
		   				//out<<"OPERATOR"<<"\t"<<pattern[i]<<"\n";
		   			
		   			    if(pattern[i]==':'){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
						if(pattern[i]==';'){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]==','){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]=='('){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]==')'){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]=='{'){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]=='}'){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]=='['){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
                        if(pattern[i]==']'){
                        	myTokens.push_back(Token("Delimiter",s,line_num));
                        }
		   				i++;
		   			}
		   			
		   			if(pattern[i]==' '){
		   				i++;
		   			}

                   str="";
		   		   }
		         }
			   }
		   while(i<pattern.length());
	}


